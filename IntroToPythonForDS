Intro to Python in Data Science:

1)type(variable_name) ==> type fn gives the data type of the variable. 
  Eg: type(variable_name)m == > o/p = int or str or float or bool or List
2)we cant concatinate diff datatypes in python,we have to type cast them to add
  Eg :print ("my BMI is : " + BMI) ==> this will throw compilation error,hence we need to type catt BMI(float type) to String
     i.e print ("my BMI is : " + str(BMI)) ==> o/p my BMI is : 20.798281126222715
     lly we can do below things as well
      1.print("I can add integers, like " + str(5) + " to strings.") ==> o/p =I can add integers, like 5 to strings.
    **2. print("I said " + ("Hey " * 2) + "Hey!")                    ==> o/p =I said Hey Hey Hey!
   ***3. print(True + False)                                         ==> o/p =1
3)variable declaration with values
    ==> int = 1 (integers)
    ==> float = 1.1 (real numbers)
    ==> str = "Bulzer" (string or text values)
    ==> bool = True (true or false)
4)Lists:
One more data type is lists(List is a compount data type(i.e it can have diff. type of values))
    --> lists can store values of diff data types
    --> lists are enclosed in sq. braces
    --> lists can contain other lists in them
    -->Eg: list1 = ["Bulzer",24,"human"]
    --> python uses indexes to access the elements of the list (Zero based indexing).we can also use Slicing to access the elements in a list(o/p after slicing is also a List)
        ==> print(list1[0]) ==> o/p = Bulzer
        ==> print(list1[1]) ==> o/p = 24
        ==> print(list1[2]) ==> o/p = Human
      **we can also access the elements using -ve indexes(we mostle use this to access the elements from the last)
        ==> print(list1[-1]) ==> o/p = human
        ==> print(list1[-2]) ==> o/p = 24 
      **==> to get a value present in a list which is present in another list ==> print(lista[2][2])
    Slicing:
        Eg: list2 = ["Bulzer",24,"human",1,2,3,4,5,6]
      **==> print(list2[2:4])  ==> o/p = ['human', 1] 
      **i.e as we gave 2:4 ==> starts with index value as 2(inclusive) and end with index value as 4(exclusive)
        ==>print(list2[:4]) ==> prints all the elements from 0th indes till 3rd index
        ==>print(list2[4:]) ==> prints all the elements from index no. 4 till last element(including the last element as well
5)List Manipulations(interchange or add or remove elements):
        ==> change element ==> list2[2]=23 ==> gets changed
                        lly ==> list2[0:2]=['bulzers',24] ==> 2 elements gets  changed 
        ==> to add ==> list3 = list2[]+ ["sid",1,1,] ==> lly we can add 2 lists using + sign
        ==> to delete ==>use del() function Eg: del(list2[3])
     ***==>Understanding how Python lists actually work behind the scenes becomes pretty important now. What actually happens when you create a new list, `x` [‘a’,’b’,’c’], like this?
           Well, in a simplified sense, you're storing a list in your computer memory, and 
           store the 'address' of that list, so where the list is in your computer memory, in `x`. This means
           that `x` does not actually contain all the list elements, it rather contains a reference
           to the list. For basic operations, the difference is not that important, but it becomes more
           so when you start copying lists. Let me clarify this with an example.
           Let's store the list `x` as a new variable `y`, by simply using the equals sign:  y = x
           Let's now change the element with index one in the list `y`, as follows:  y[1] =”z” and print y ==>o/p = [‘a’,’z’,’c’],
           The funky thing is that if you now check out `x` again, also here the second element is changed,hence printing X also gives o/p = [‘a’,’z’,’c’],
           That's because when you copied x to y with the equals sign, you copied the reference
           to the list, not the actual values themselves. When you're updating an element the list,
           though, it's one and the same list in the computer memory your changing. Both `x` and
           `y` point to this list, so the update is visible from both.
           If you want to create a list `y` that points to a new list in the memory with the same
           variables, you'll need to use something else than the equals sign. You can use the `list()`
           function, like this, or use slicing to select all list elements explicitly.
           If you now make a change to the list `y` points to, `x` is not affected:
           ==> we have to copy elements only(not their references)like this 
                  y = list(x) or y = [x:] ==> now if we change the elements of Y they wont be reflecting in X,hen
6)Functions:
* use help(fn name) or ?fn_name to know abt the fn i.e help fn shows the documentation of a function in python.
  a)type() ==> give datatype of a variable
  b)round(number[,ndigits) ==> round a value 2 type of i/p a)one input(here default 2nd input(i.e ndigits is optional) is taken) b) 2 inputs  
    ** ndigits is present in b/e [,----] ==> this is to represent optional argument to a fn
    a)round(1.68) ==> round to nearest integer ==> o/p =2
    b)round(1.68,1) ==> rounds to one decimal(i.e precision is one) ==> o/p = 1.7
    c)round(111.487,1) ==> o/p = 111.5
    d)round(111.487,0) ==> o/p = 111.0
    e)round(111.487,-0) ==> o/p = 111.0  
    f)round(111.487,-1) ==> o/p = 110.0
    g)round(111.487,-2) ==> o/p = 100.0
  c)min(x) ==> gives the minimun value in the list X
  d)max(x) ==> gives the maximum value in the list X
  e)len() ==> gives lengths of Lists and Strings Eg:len(list1) ==> o/p = 10
  f)int(),float(),str(),bool() ==> converts to int or float or string or boolean
  g)sorted() ==> sorts elements in ascending or descending order
    sorted(list1) ==> sorts in ascending opder
    sorted(list1,reverse=True) ==> sorts in descending order

7)Methods:
Functions that belong to objects are called methods 
    Eg: a = 1.0 b = "1" c = [1] ==> all a,b,c are Objects(variables as well,every thing in python is an object) of type float, str and list respectively
    hence we have fns like capitalize(),replace(),etc for string type objects 
    and fns like bit_length(),conjugate(),etc for float type objects 
    and fns like index(),count(),etc for list type objects
    ==> to get the index of bulzer in list2 ==> list2.index("Bulzer") 
        lly we can use count method to find no. of times Bulzer is present in the list (list2.count("Bulzer")
        lly we can add append elements to list using append() ==> list2.append("abc")
        lly use reverse() to reverse the list
    **Note:Append() can take only one argument at a time
    ==>lly for string say we have Sister="liz"
    ==> sister.capitalize() ==> changes first letter to a capital one ==> o/p = Liz
        to change all the elements into upper case ==> use sister.upper()
        sister.replace("z","sa") ==> changes z to sa ==> o/p = lisa
Therefore everything in python is an object an deach object have its own methods depending on the type of object
We can also have same method name for diff type of object(Eg: we have index() for both string and List, for string we get the index of the characters in the string and in list we get the index of the elements in the list

8)Packages(also called as modules):
Numphy       --> to deal with arrays efficiently
Matplotlib   --> for data visualization
Scikit-learn --> for machine learning
To install a package we need to use PIP(a package maintenance system for python)
==> go to URL : http://pip.getthedocs.org/en/stable/installing/ and download get-pip.py file
    then go to terminal and execute python3 get-pip.py ==> now we can use pip to install other packages
    Eg: to install Numpy ==> type pip3 install numpy (pip3 and python3 tells we are using puthon 3)
    ==> noe use import command in code to use the package
    Eg : import Numpy(usage numpy.array([1,2,3]) (or) import Numpy as np ( to use np instead of Numphy)
  **to use only one specific fn from a package ==> from package_name import fn_name
    Eg: if we want to use only arrays from Numphy ==> from Numpy import arrays ==> we can use use only arrays from Numpy,
        **here we can directly call the array function like this array([1,2,3])
    Eg: Moon travels 12 degrees ==> distance travelled by moon = (radius * math.radians(12)) (converting radians into degrees usinge radians fnin math package)
  **Eg: Suppose you want to use the function inv(), which is in the linalg subpackage of the scipy package. You want to be able to use this function as follows:
        my_inv([[1,2], [3,4]]),which import statement we use ?
        Ans = from scipy.linalg import inv as my_inv
9)Numpy(numeric Python--use mostly to do vector arithmetic)
    **Note: numpy arrays can contain values of only one type
      eg: if we declare an numpy arrar as np.array([1.0,"us",True])
    **==> every element gets converted to a string i.e it becomes as ["10","is","True"].This behaviour is called type coercion.
    dtype = '<U32' represents it of string type
      Therefore numphy array is kind of a new datatype in python llr to int,float,str,bool,list etc and numpr array has its own methods
    **Eg: if we have 2 lists say l1=[1,2,3] and l2=[1,2,3] and if we do l3 = l1 + l2 ==> o/p = [1,2,3,1,2,3]
          but if these 2 lists were numpy arrays and we do l3 = l1 + l2 ==> o/p = [2,4,6] i.e it does addition
    Questions:
    1)why do we use numphy array when we already have normal python lists ?
    Sol:Numphy arrays are alternatives to noral python lists as they are fast and we can perform many operatios on them over the entire ayyay elements at ones.
    Eg: we have 2 lists containing weights and heights of the persons and we need to calculate BMI
     ==> say listW = [1,2,3,4,5]
             listH= [1,2,3,4,5]
             ==> BMI = listw/listH**2 ==> we get compilation error reasons a) cant have squares of all the elements in a list
                                                                       b) cant divide list by a list
        Now , we convert these list to numpy arrays
         ==> np_height= np.array(listH)
         np_weight=np.array(listW)
         BMI = npp_weight/np_height**2 ==> works fine ==> o/p = [ 1 , .5, .33 , .25, .2]
        * type(listH) ==> o/p = numpy,ndarray ==> means it is a Numpy array and it is an N dimentional array(ndarray)
     **we can also do other operations on np array like
      a) BMI > .25 ==> gives an array containing of boolean values if BMI is greater that 25 ==< true else false i.e [True,True,True,True,False]
      b) BMI[BMI < .25](use squaRE BRACES here) ==> gives the value(s) of the bmi which are less than .25 ==> o/p = [.2] (o/p is also an array)
         say temp = BMI < .25 ==>print (BMI[temp])  gives the same result as above.
     2D-Numpy Array(we can create till 7 D arrays):
      1) we can create a 2 D numpy array like this 2d_array=np.array([[1,2,3,4],[5,6,7,8]])
      2)2d_array.shape ==> o/p = (2,4) i.e 2 rows and 4 columns 
      ** Shape is called the attribute of the array
      3)2d_array[0] ==> gives the first full row as o/p (we can also use 2d_array[0,:]
        2d_array[0][1] ==> gives the 2nd element of the first row and process is called subsetting
        2d_array[0,1]  ==> also gives the 2nd element of the first row and process is called subsetting
        subsetting : process to get the sub elements in an List or an array
        2d_array[:,1:3] ==> gives the 1st nd 2nd column values of both the rows
       **we can directly convert a list containing set of lists into a 2D array (eg: np.array(list_name))
       we have other methods which we can use in Numpy
       Eg : 1)np.mean(2d_array[0]) --> gives mean of the 1st row of array (average of elements)
            2)np.median(2d_array[0]) --> gives median of the 1st row of array(if all the elements are arranged in ascendenging/descending order the middle one is the median)
            3)np.corrcoef(2d_array[0],2d_array[0]) --> this fn tells if row 1(say height) and row 2(say weight) are co-related
            4)np.std(2d_array[0]) --> gives the standard deviation of the list of elements
       4)Numpy also has basic fn like sun(),sort() etc which are also present in normal python,but these are faster in numpy.
       5)we can use np.column_stack((array1,array2) to combine 2 arrays and use them as together as 2 columns.
       
      
